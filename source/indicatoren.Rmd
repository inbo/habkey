---
output: html_document
editor_options: 
  chunk_output_type: console
---
In dit onderdeel wordt de metadata van de opname aangevuld met enkele kenmerken.
Ze worden bewaard, zodat ze voor andere toepassingen beschikbaar komen.
Binnen het project is het nuttig om ze te hebben, om niet terugkerend tijdens 
de determinatie ze te moeten herberekenen.

```{r knitr, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, # Toon de code (optioneel)
  message = TRUE, # FALSE Verbergt alle messages
  warning = TRUE, # FALSE Verbergt alle warnings
  include = TRUE
)
```


```{r pakketten}
library(tidyverse)
```


```{r setup}
path_data <- file.path("data", "bron", "access")
path_data_int <- file.path("data", "interim")
path_data_proc <- file.path("data", "processed")
```

```{r parameters}
sleutel_code <- "H" # de opgegeven sleutel

# Ook de velden mbt bedekking lagen herberekenen?
recalculate_layers <- TRUE
```
# Inlezen data

```{r inlezen data}


# kopgegevens opname
df_meta_bron <- read.csv2(
  file.path(path_data, "test_kopgegevens.csv")
)

# opname
df_opnamen_bron <- read.csv2(
  file.path(path_data, "test_soortgegevens.csv")
)

# codetabel vegetatielagen opname
df_layer_mapping <- read.csv2(
  file.path(path_data, "cde_layer.csv")
)

# soortenlijsten
#   standaardlijst inbo
file_taxa <-  file.path(path_data_proc, "taxa.csv")
if (!file.exists(file_taxa)) stop("Bestand 'taxa.csv' niet gevonden.")

soorten_inbo <- read.csv2(file_taxa, stringsAsFactors = FALSE)

#   soortenlijst Access
file_syno <-  file.path(path_data, "specsyno.csv")
if (!file.exists(file_syno)) stop("Bestand 'specsyno.csv' niet gevonden.")

soorten_acc <- read.csv2(file_syno, stringsAsFactors = FALSE)

#   eigen soortenlijst
# als die bestaat wordt deze ingeladen, anders wordt er een lege tabel gemaakt.
# en een volgnummer begonnen
file_custom <- file.path(path_data, "custom_taxalijst.csv")
prefix_id <- "CU"
if (file.exists(file_custom)) {
  custom_taxa <- read.csv2(file_custom, stringsAsFactors = FALSE)
  ids_num <- gsub(paste0("^", prefix_id), "", custom_taxa$taxonid)

  if (length(ids_num) == 0) {
    laatste_nummer <- 0
  } else {
    laatste_nummer <- max(as.numeric(ids_num), na.rm = TRUE)
  }

} else {
  custom_taxa <- soorten_inbo[0, ]
  laatste_nummer <- 0
}


```

# Controle van de soortnamen
## Komen de soortnamen uit de opnamen allemaal voor in de inbo-standaardlijst
```{r controle soortnamen}

# 1. Referentie-pool opbouwen voor de check
# We maken een vector van ALLE bekende namen en zetten deze naar kleine letters
bekende_namen_raw <- unique(c(
  soorten_inbo$tax_orig,
  soorten_inbo$tax_canon,
  soorten_inbo$taxon,
  soorten_acc$originalna,
  soorten_acc$specieszonderauteur_ori,
  custom_taxa$tax_orig,
  custom_taxa$tax_canon
))

# omzetten van de soortnamen in kleine letters omdat dit anders onterecht
# aanleiding kan geven voor een (verkeerde) nieuwe soort-melding
bekende_namen_lower <- tolower(na.omit(bekende_namen_raw))

# dit ook alleen doen voor de namen van de alleen officiÃ«le lijst
officiele_taxa_lower <- tolower(unique(soorten_inbo$taxon))

# soortnamen ophalen uit de opnamen
soorten_opg <- unique(df_opnamen_bron$speciesnam)

# De functie 'valideer_vegetatie_namen' uitvoeren
source(file.path("source", "custom_taxalijst.R"))

# nolint start
mijn_bijgewerkte_lijst <-
  valideer_vegetatie_namen(soorten_opg,
                           bekende_namen_lower = bekende_namen_lower,
                           officiele_taxa_lower = officiele_taxa_lower,
                           prefix_id = prefix_id,
                           custom_taxa = custom_taxa,
                           laatste_nummer = laatste_nummer,
                           file_custom = file_custom
                           )
# nolint end

# Bekijk het resultaat
head(mijn_bijgewerkte_lijst)

```



```{r indicatoren}


# Helper functie: Fisher som voor bedekking (gebruikt doorheen de VBA code)
# Formule: 100 maal (1 - exp(sum(log((100 - p + 0.01) / 100))))
fisher_sum <- function(p) {
  if (length(p) == 0 || all(is.na(p))) return(0)
  res <- 1 - exp(sum(log((100 - p + 0.01) / 100), na.rm = TRUE))
  return(as.integer(res * 100))
}

indicatoren_bijwerken_r <- function(df_meta,
                                    df_opnamen,
                                    df_specsyno,
                                    df_layer_mapping,
                                    df_ellenberg,
                                    df_soorten,
                                    df_indicator_soortenlijst,
                                    df_indicatoren,
                                    sleutel_groep,
                                    recalculate_layers = FALSE) {
  stopifnot(require("dplyr"))


  # 1. Reset indicatoren (VBA [cite: 247-253])
  # Zet alle numerieke velden die niet in de uitzonderingslijst staan op 0
  cols_to_keep <- c("uniek", "name", "spoc", "opn", "survey", "plaats",
                    "recording", "Observer", "waarnemer", "user_reference",
                    "vast", "regel")

  df_meta <- df_meta_bron |>
    mutate(across(where(is.numeric) & !contains(cols_to_keep), ~0))


  # 2. Herberekenen bedekking lagen (indien gekozen) [cite: 55-242]
  if (recalculate_layers) {
    # check de soortgegevens of deze de kolom "layer_bron" bevat
    if (!"layer_bron" %in% colnames(df_opnamen)) {
      stop("Geen veld 'layer_bron' gevonden in de tabel met de soortgegevens. 
           Mogelijk is de layer-informatie niet correct: niet volgens de 
           vereenvoudigde indeling cfr. cde_layer.")
    }

    # check de kopgegevens of deze de kolom " kruideninklbedekking_vast" bevat
    if (!"kruideninkl_bedekking_vast" %in% colnames(df_meta)) {
      stop("Geen veld 'kruideninkl_bedekking_vast' gevonden in de 
           tabel met de kopgegevens. Hierdoor is het niet mogelijk om per opname
            de bedekking van de kruiden in de kruidlaag in te vullen.")
    }

    # Vereenvoudiging lagen via cdeLayer [cite: 64-65]
    df_opnamen <- df_opnamen_bron |>
      left_join(df_layer_mapping, by = c("layer_bron" = "layer_code"),
                # toevoegen van suffix '.map' aan de rechtertabel mochten er
                # kolommen dezelfde naam hebben die niet in de join zitten.
                # Dat is hier inderdaad het geval voor de kolom 'layer'
                suffix = c("", ".map")) |>
      mutate(layer = coalesce(.data$layer, .data$layer.map)) |>
      select(-.data$layer.map, -id)

    # Berekenen Kruiden in Kruidlaag (Fisher som) [cite: 84-88, 113-117]
    kruiden_kl <- df_opnamen |>
      inner_join(df_specsyno, by = c("SpeciesNam" = "ORIGINALNA")) |>
      filter((.data$Layer == "K" | .data$Layer == "X") & .data$VAATPLANT &
               !.data$IsEenBoomStruik &
               !.data$IsEenDwergstruik) |>
      group_by(.data$RecordingGivid) |>
      summarise(kruideninklbedekking_vast = fisher_sum(.data$percentage))

    # Berekenen Niet-Kruiden in Kruidlaag
    niet_kruiden_kl <- df_opnamen |>
      inner_join(df_specsyno, by = c("SpeciesNam" = "ORIGINALNA")) |>
      filter((.data$Layer == "K" | .data$Layer == "X") & .data$VAATPLANT &
               (.data$IsEenBoomStruik | .data$IsEenDwergstruik)) |>
      group_by(.data$RecordingGivid) |>
      summarise(NietKruidenInKLBedekking_vast = fisher_sum(.data$Percentage))

    df_meta <- df_meta |>
      left_join(kruiden_kl, by = "RecordingGivid") |>
      left_join(niet_kruiden_kl, by = "RecordingGivid")
  }

  # 3. Ellenberggetallen (Gewogen gemiddelden) [cite: 48-52]
  ellenberg_calc <- df_opnamen |>
    inner_join(df_specsyno, by = c("SpeciesNam" = "ORIGINALNA")) |>
    inner_join(df_ellenberg, by = c("SPECIESNAM" = "ScientnameBelgium")) |>
    filter(.data$Layer == "K" | .data$Layer == "x") |>
    group_by(.data$RecordingGivid) |>
    summarise(
      Lgetal = round(sum(.data$L * .data$Percentage) / sum(.data$Percentage),
                     2),
      Fgetal = round(sum(.data$F * .data$Percentage) / sum(.data$Percentage),
                     2),
      Rgetal = round(sum(.data$R * .data$Percentage) / sum(.data$Percentage),
                     2),
      Ngetal = round(sum(.data$N * .data$Percentage) / sum(.data$Percentage),
                     2),
      Sgetal = round(sum(.data$S * .data$Percentage) / sum(.data$Percentage),
                     2),
      RNgetal = round(sum(.data$N * .data$R * .data$Percentage) /
                        sum(.data$Percentage), 2)
    )

  df_meta <- df_meta |> rows_update(ellenberg_calc, by = "RecordingGivid")

  # 4. Soortenaantal [cite: 55]
  soortenaantal <- df_opnamen |>
    group_by(.data$RecordingGivid) |>
    summarise(Soortenaantal = n_distinct(.data$SPECIESNAM))

  df_meta <- df_meta |> left_join(soortenaantal, by = "RecordingGivid")

  # 5. Aandeel gras [cite: 58-59]
  gras_aandeel <- df_opnamen |>
    inner_join(df_specsyno, by = "SPECIESNAM") |>
    filter(.data$Layer == "K" | .data$Layer == "x") |>
    group_by(.data$RecordingGivid) |>
    summarise(
      AandeelGras =
        (sum(ifelse(.data$iseengras == -1, .data$Percentage, 0)) * 100) /
        sum(.data$Percentage)
    )

  df_meta <- df_meta |> left_join(gras_aandeel, by = "RecordingGivid")

  # 6. Bosbedekking (Complexere logica met Fisher som en 100% checks)
  bos_bedekking <- df_opnamen |>
    filter(.data$Layer %in% c("B", "S")) |>
    group_by(.data$RecordingGivid) |>
    summarise(
      B_perc = max(ifelse(grepl("^B", .data$Layer), .data$CoverPctValue, NA),
                   na.rm = TRUE),
      S_perc = max(ifelse(grepl("^S", .data$Layer), .data$CoverPctValue, NA),
                   na.rm = TRUE)
    ) |>
    mutate(BosBedekking = case_when(
      B_perc == 100 | S_perc == 100 ~ 100,
      is.na(B_perc) ~ S_perc,
      is.na(S_perc) ~ B_perc,
      TRUE ~
        (1 - exp(log((100 - B_perc) / 100) + log((100 - S_perc) / 100))) * 100
    ))

  df_meta <- df_meta |> left_join(bos_bedekking |>
                                    select(.data$RecordingGivid,
                                           .data$BosBedekking),
                                  by = "RecordingGivid")

  # 7. Dynamische Indicatoren (Lussen door de soortenlijsten) [cite: 91-105]
  # In R doen we dit door de criteria te filteren en te joinen
  indicator_results <- df_indicator_soortenlijst |>
    filter(.data$HRLCode == sleutel_groep & !is.na(.data$Veldnaam)) |>
    inner_join(df_indicatoren, by = c("VolgnrCriterium" = "Volgnr")) |>
    inner_join(df_soorten, by = "SoortenlijstNr") |>
    inner_join(df_opnamen, by = c("WetNaam" = "SPECIESNAM")) |>
    group_by(.data$RecordingGivid, .data$Veldnaam, .data$Aard)

  # Bereken bedekking of aantal per indicator [cite: 92, 100]
  dyn_summary <- indicator_results |>
    summarise(
      Waarde = if_else(first(.data$Aard) == "bedekking", sum(.data$Percentage),
                       as.double(n())),
      .groups = "drop"
    ) |>
    tidyr::pivot_wider(names_from = .data$Veldnaam, values_from = .data$Waarde,
                       values_fill = 0)

  df_meta <- df_meta |> left_join(dyn_summary, by = "RecordingGivid")

  return(df_meta)
}
```

