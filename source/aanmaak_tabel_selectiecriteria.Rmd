---
output: html_document
editor_options: 
  chunk_output_type: console
---
In access is er een algoritme dat door een beslissingsboom (de "Sleutel") wandelt om te reconstrueren welke stappen (regels) leiden naar een specifiek habitattype. De functie Aanmaak_Tabel_Selectiecriteria doet het werk.

De code voert de volgende kernstappen uit:


- Initialisatie: Het bepaalt de doeltabel op basis van een gekozen sleutel (cbo_sleutel) en maakt een back-up van de bestaande tabel.

- Iteratie over Habitattypen: Het loopt door alle habitattypen in de tabel _cde_Habitattypen.

- `Pathfinding` (Achterwaarts zoeken): Voor elk habitattype zoekt het in _tbl_Sleutel waar dit type als uitkomst ("Ja" of "Nee") staat.

- Boomstructuur reconstrueren: Zodra een uitkomst gevonden is, "klimt" de code omhoog in de boom door te zoeken naar de "moeder-regel" (de regel die naar het huidige niveau leidde).

- Matrix invullen: De resultaten worden opgeslagen in een 3D-array die uiteindelijk naar een tabel wordt geschreven.

```{r knitr, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, # Toon de code (optioneel)
  message = TRUE, # FALSE Verbergt alle messages
  warning = TRUE, # FALSE Verbergt alle warnings
  include = TRUE
)
```


```{r pakketten}
library(tidyverse)
```


```{r setup}
path_data <- file.path("data", "bron", "access")
```

```{r parameters}
sleutel_code <- "H" # de opgegeven sleutel
```


# 1. Voorbereiding: Haal tabellen op
```{r ophalen tabellen}
# 1. Voorbereiding: Haal tabellen op
# lijst met habitattypen
str_tabel_ht <- read.csv2(file.path(path_data, "cde_typen.csv"))

# lijst met sleutels
cde_tabellen <- read.csv2(file.path(path_data, "cde_sleutels.csv"))

# sleutel
df_sleutel <- read.csv2(file.path(path_data, "tbl_sleutel.csv"))

# ophalen tabel met de sleuteluitkomsten voor de opgegeven sleutel
sleutel_naam <- cde_tabellen %>%
  filter(code == sleutel_code) %>%
  pull(tabelnaam) %>%
  tolower()

filenaam_tbl_sleuteluitkomst <- paste0("tbl_sleutel_uitkomst_", sleutel_naam)
file_tbl_sleuteluitkomst <-
  file.path(path_data, paste0(filenaam_tbl_sleuteluitkomst, ".csv"))

if (file.exists(file_tbl_sleuteluitkomst)) {
  str_tabel_doel <-
    read.csv2(file_tbl_sleuteluitkomst)
} else {
  stop(paste(
    "Bestand", filenaam_tbl_sleuteluitkomst,
    "niet gevonden. Maak eerst zelf eerst een lege structuurtabel."
  ))
}

# de huidige versie backuppen (onder de naam ..._bu.csv)
file.copy(
  from = file_tbl_sleuteluitkomst,
  to = file.path(path_data, paste0(
    filenaam_tbl_sleuteluitkomst,
    "_bu.csv"
  )),
  overwrite = TRUE
)
str_tabel_doel_bu <- str_tabel_doel

# regels verwijderen
str_tabel_doel <- str_tabel_doel[0, ]
rm(file_tbl_sleuteluitkomst)
```
# 2. Controle op kringverwijzingen
Deze functie doorloopt de boom vanaf de wortel en houdt bij welke knopen (niveaus) hij al is tegengekomen in het huidige pad.
```{r check-kringverwijzingen}

check_sleutel_cycli <- function(df_sleutel, sleutel_code) {
  stopifnot(require("dplyr"))

  # 1. Filter de data voor de relevante sleutelgroep [cite: 8]
  df_check <- df_sleutel |>
    filter(.data$tabel == sleutel_code) |>
    select(.data$niveau, .data$bij_ja, .data$bij_nee)

  # Interne helperfunctie voor Depth-First Search
  detecteer_lus <- function(huidig_niv, pad_geschiedenis) {
    # Als het huidige niveau al in het pad zit, hebben we een lus gevonden!
    if (huidig_niv %in% pad_geschiedenis) {
      return(list(status = TRUE, lus = c(pad_geschiedenis, huidig_niv)))
    }

    # Zoek de rij voor het huidige niveau
    rij <- df_check %>% filter(.data$niveau == huidig_niv)
    if (nrow(rij) == 0) return(list(status = FALSE)) # Eindpunt bereikt

    # Check het 'Ja' pad en het 'Nee' pad
    paden <- c(rij$bij_ja, rij$bij_nee)
    paden <- paden[!is.na(paden) & paden > 0] # Negeer lege of eind-waarden

    for (volgend_niv in paden) {
      resultaat <- detecteer_lus(volgend_niv, c(pad_geschiedenis, huidig_niv))
      if (resultaat$status) return(resultaat)
    }

    return(list(status = FALSE))
  }

  # Start de controle vanaf niveau 1 (of alle beginpunten)
  start_punten <-
    df_check$niveau[!(df_check$niveau %in% c(df_check$bij_ja,
                                             df_check$bij_nee))]
  if (length(start_punten) == 0) start_punten <- df_check$niveau[1]

  for (start in start_punten) {
    check <- detecteer_lus(start, c())
    if (check$status) {
      message <- paste("LUS GEVONDEN in tabel", sleutel_code, ":",
                       paste(check$lus, collapse = " -> "))
      stop(message)
    }
  }

  print(paste("Sleutel", sleutel_code, "is veilig bevonden (geen lussen)."))
  return(TRUE)
}

# toepassen van de functie
check_sleutel_cycli(df_sleutel, sleutel_code)
```




# 3. De Kernlogica: `Backtracking` in de boom
De code zoekt voor elk habitattype waar het in de ja_uitkomst of nee_uitkomst staat en klimt dan omhoog in de sleutel om zo de gemaakte keuzen bij de determinatie te reconstrueren.

```{r backtracking}
# Hulpfunctie om kolomnaam te genereren (VBA Bron 12, 16, 29)
genereer_veldnaam <- function(niv, subniv) {
  sub_str <- if (subniv > 0 && subniv < 99) as.character(subniv) else ""
  kolom_regels[
    kolom_regels$link == sprintf("regel%03d%s", niv, sub_str),
  ]$kolomnaam
}

# kolomnamen selecteren
kolomnaam <- grep("^regel\\d{3,5}", names(str_tabel_doel), value = TRUE)

# We behouden alleen de eerste 9 karakters (regel + 3 cijfers)
link <- sub("(^regel\\d{3,5}).*", "\\1", kolomnaam)
kolom_regels <- data.frame(kolomnaam, link)
rm(link)

# backtracking functie


# Interne recursieve functie om omhoog te klimmen
walk_up <- function(curr_node, path_so_far, df, ht_naam) {
  stopifnot(require("dplyr"))
  df_sleutel_ht <- df
  # Verwerk het huidige niveau in het pad
  # Logica voor subniveau 99
  # bij 99 zijn alle stappen van het multicriterium nee-antwoorden
  if (!is.na(curr_node$subniveau) && curr_node$subniveau == 99) {
    sub_regels <- df_sleutel_ht |>
      filter(.data$niveau == curr_node$niveau & .data$subniveau < 99)
    for (j in seq_len(nrow(sub_regels))) {
      veld <- genereer_veldnaam(sub_regels$niveau[j], sub_regels$subniveau[j])
      path_so_far[[veld]] <- 0
    }
  } else {
    # bij een normaal niveau of specifiek subniveau
    curr_node$subniveau <- replace_na(curr_node$subniveau, -1)
    veld <- genereer_veldnaam(curr_node$niveau, curr_node$subniveau)
    path_so_far[[veld]] <- curr_node$waarde
  }

  # Zoek ALLE moeders
  parents <- df_sleutel_ht |>
    filter(.data$bij_ja == curr_node$niveau | .data$bij_nee == curr_node$niveau)

  # Als er geen moeders meer zijn, is dit pad voltooid
  if (nrow(parents) == 0) {
    resultaat <- as.data.frame(path_so_far)
    resultaat$conclusie <- ht_naam

    str_tabel_doel <- str_tabel_doel  |>
      bind_rows(resultaat)

    return(str_tabel_doel)
  }

  # Als er wel moeders zijn, ga voor ELKE moeder verder
  purrr::map_df(seq_len(nrow(parents)), function(idx) {
    p_node <- parents[idx, ]
    # Bepaal de waarde van de moeder (was het een 'Ja' of 'Nee' pad?)
    p_node$waarde <- ifelse(p_node$bij_ja == curr_node$niveau, 1, 0)

    walk_up(p_node, path_so_far, df, ht_naam) # in R kan men dus in een functie
    # verwijzen naar dezelfde functie !
    # Daarom is het wel opletten voor kringverwijzingen. Hierop moet eerst
    # gecontroleerd worden.
  })
}

verwerk_ht_met_vertakkingen <- function(ht_naam) {
  stopifnot(require("tidyr"))
  stopifnot(require("dplyr"))
  # 1. De sleutel beperken tot het habitattype
  df_sleutel_ht <- df_sleutel |>
    filter(.data$tabel == sleutel_code)

  # 2. Zoek startpunten

  starts_ja <- df_sleutel_ht |>
    filter(.data$ja_uitkomst == ht_naam)  |>
    mutate(waarde = 1)

  starts_nee <- df_sleutel_ht |>
    filter(.data$nee_uitkomst == ht_naam) |>
    mutate(waarde = 0)

  start_nodes <- bind_rows(starts_ja, starts_nee)


  # 3. Start de wandeling voor elk startpunt
  if (nrow(start_nodes) > 0) {
    alle_paden <- purrr::map_df(seq_len(nrow(start_nodes)), function(i) {
      walk_up(start_nodes[i, ], list(), df = df_sleutel_ht, ht_naam)
    })
  } else {
    alle_paden <- str_tabel_doel[0, ]
  }
  return(alle_paden)
}

```
```{r toepassen functie}
# alle mogelijke uitkomsten oplijsten
habitat_lijst <- str_tabel_ht[[1]] # De eerste kolom met de codes

# toepassen functie
finaal_resultaat <- purrr::map_df(habitat_lijst, function(ht) {
  verwerk_ht_met_vertakkingen(ht)
})

# toevoegen van een uniek nummer
finaal_resultaat <- finaal_resultaat |>
  mutate(volgnr = row_number()) # de kolom volgnr bestaat al, maar was nog leeg

# check
check <- finaal_resultaat |>
  select(-c(1:3)) |>
  distinct()
if (nrow(check) != nrow(finaal_resultaat)) {
  stop("De uitkomsten zijn niet uniek. Kijk dit aub na.")
}

# bewaren van het resultaat
write_csv2(finaal_resultaat,
           file.path("data", "processed",
                     paste0(filenaam_tbl_sleuteluitkomst, ".csv")))
```

